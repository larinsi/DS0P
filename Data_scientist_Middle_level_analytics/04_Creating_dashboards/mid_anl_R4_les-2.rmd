---
title: "Урок 2. Обзор возможностей Shiny: часть 1"
output:
  pdf_document: default
  html_document:
    df_print: paged
header-includes:
- \usepackage[russian]{babel}
- \usepackage{hyperref}
- \hypersetup{ colorlinks = true, urlcolor = blue}
---

В этом уроке мы посмотрим на устройство кода для дэшборда, для приложения Shiny. Начнем с разбора кода из шаблонного файла с гистограммой, который мы видели в предыдущем уроке. 

Гистограмму мы будем строить для одного из показателей из встроенного в R датафрейма `faithful`. Можем запросить описание этого датафрейма:

```{r, eval=FALSE}
help(faithful)
```

Датафрейм содержит данные по извержениям гейзера *Old Faithful* в США и состоит из двух столбцов: `eruptions` – длительность извержения в минутах, `waiting` – время между извержениями в минутах.
Перейдем к коду. 

Заметим, что раз мы работаем не просто с блоком кода для анализа данных или построения графика, а с приложением, все строки кода заключены в функции. Этих функций две. Первая из них отвечает за интерфейс для пользователя (`ui` от `user interface`). В нее включаются все кнопки, «бегунки», выпадающие меню и детали, связанные с оформление страницы. Вторая функция описывает действия, которые должны выполняться в зависимости от того, что выберет пользователь (`server`). В данном случае там содержится код для построения гистограммы.

Если знакомы с веб-дизайном, условно можно считать, что первая функция – это аналог файла HTML с разметкой страницы и файла CSS со стилем и оформлением этой страницы, а вторая функция – аналог файла с кодом JavaScript, который отвечает за выполнение определенных действий, активацию функций в зависимости от действий пользователя. Кстати, RStudio тоже предлагал разделить эти две функции и поместить в разные файлы, но мы выбрали один (*single file*) – помните?

Начнем с первой функции. 

```{r, eval=FALSE}
ui <- fluidPage(
  # Application title
   titlePanel("Old Faithful Geyser Data"),
  # Sidebar with a slider input for number of bins 
   sidebarLayout(
	sidebarPanel(
		sliderInput("bins", "Number of bins:", 
				min = 1, max = 50, value = 30)
			),
  # Show a plot of the generated distribution
   mainPanel(
	plotOutput("distPlot"
	 )
    )
 )
```

Функция `ui` содержит целый набор вложенных друг в друга функций. К этим функциям можно относиться как к слоям. Первый слой `fluidPage` — главный, отвечает за создание страницы. 

Что у нас есть на странице? Если вернемся к тому, как она выглядит в отдельном окне, мы увидим, что на ней есть несколько областей. Во-первых, область с заголовком (показать), область с главной панелью, где отображается график или таблица, главный объект, который мы хотим показать, и область с боковой панелью, где обычно располагается меню.
Итак, внутри этой страницы мы добавляем панель с заголовком (`titlePanel`), боковую панель с меню (`sidebarLayout`) и основную панель `mainPanel`, в которой будет график. Внутри боковой панели размещается «бегунок» или слайдер для выбора числа столбцов (`sliderInput`).

Первый аргумент в `sliderInput()`, `"bins"` — это название переменной (`inputId`), в которой будет сохранено значение числа столбцов, которое выберет пользователь. Далее это значение будет использовано для обновления гистограммы. На втором месте стоит заголовок для слайдера (`label`) – текст, который мы видим над «бегунком» на странице. Далее указано максимальное и минимальное число столбцов, а также значение по умолчанию (`value`), то значение, на котором будет стоять «бегунок» при запуске приложения, то есть до того, как пользователь что-то выберет сам). 

Последние строки этой функции – строки кода для отображения графика на основной панели. Внутри `mainPanel` мы добавляем график, который называем `distPlot`, и помещаем его внутри функции `plotOutput` для отображения на странице. 
Теперь рассмотрим более сложную, вторую функцию.

```{r, eval=FALSE}
server <- function(input, output) {
      output$distPlot <- renderPlot({
      # generate bins based on input$bins from ui.R
      x    <- faithful[, 2] 
      bins <- seq(min(x), max(x), length.out = input$bins + 1)
      # draw the histogram with the specified number of bins
      hist(x, breaks = bins, col = 'darkgray', border = 'white')
   })
}
```

Функция `server()` имеет два аргумента, `input` и `output`. В `input` хранится ввод данных пользователем, то есть значение числа столбцов, на которое он поставит «бегунок». Из этого `input` мы извлечем значение `bins` (`input$bins`) и будем использовать его для построения гистограммы. В output хранится объект, который должен отображаться на выходе, в нашем случае график. Из output мы извлекаем объект `distPlot` (`output$distPlot`) и присваиваем ему результат функции `renderPlot()`, которая сгенерирует график. 

Перейдем к самой гистограмме. Здесь гистограмма строится для второго столбца в датафрейме `faithful`, который уже загружен в R (один из встроенных датафреймов). Значения из этого столбца сохранены в вектор `x`. 

На основе параметра `bins` (`input$bins` – число столбцов; оно было определено таким образом в функции `ui` выше) определяется число разбивок на нужное число столбцов – `breaks`, поскольку уже знакомая нам функция `hist()` принимает на вход именно такой специфический аргумент.
С остальными настройками все проще. Так как пользователь не выбирает цвет и прочие параметры, они фиксируются нами. Здесь это темно-серый цвет графика (`col = 'darkgray’`), и белый цвет границ столбцов (`border = 'white'`).

Поменяем цвет гистограммы, добавим заголовок и изменим подписи к осям:

```{r, eval=FALSE}
hist(x, breaks = bins, col = 'plum', border = 'navy',
	main = "Waiting time between eruptions",
	xlab = "waiting", ylab = "counts")
```

Последняя строчка кода в файле обеспечивает вызов приложения, она соединяет воедино интерфейс и функциональный код. 

```{r, eval=FALSE}
shinyApp(ui = ui, server = server)
```

Ее не меняем. Запускаем приложение (*Run app*) и смотрим, что получилось.

Отлично! В следующем уроке мы попробуем усложнить приложение, добавить на дэшборд меню для выбора цвета гистограммы.
